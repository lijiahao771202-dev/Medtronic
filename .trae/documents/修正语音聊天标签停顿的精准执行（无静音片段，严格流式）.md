## 问题判断
- 流式增量常将标签拆分为多段（如 "[pause:1" + "0s]"），若未闭合就排程音频，会错过停顿或时长不准。
- 解码耗时导致时间轴落后，使用 `start(now+ε)` 会挤压停顿；使用 JS 等待到指针则会出现长时间无声，但这是标签要求的停顿（需可视化提示）。

## 目标
- 严格按 `[pause:Ns]`（含全角数字与中文“秒”）执行 N 秒停顿。
- 保持真正流式：文本到达立刻解析；音频片段边到边解码与就位播放；不注入静音 BufferSource。
- 可视化停顿提示（倒计时），避免“没声音像卡住”的误解。

## 技术方案
1. 解析层（`streamSegmentation.js`）
- 仅在标签完整闭合后产生停顿事件；保留残片直到 `] / ］ / 】 / ) / ） / } / ｝` 到达。
- 数字归一：将全角数字 ０–９转换为半角后再计算；单位支持 `ms/s/秒`；空格与大小写均容忍。

2. 调度层（`VoiceCall.jsx`）
- 统一时间轴指针 `scheduledCursor`：
  - 收到停顿事件：`scheduledCursor += pauseMs/1000`
  - 收到音频事件：
    1) 立刻触发解码（并发预取深度 2–3）；
    2) 若解码完成时间 < `scheduledCursor`，调用 `start(startAt=scheduledCursor)` 精确就位播放；
    3) 若解码完成时间 ≥ `scheduledCursor`，等待到 `scheduledCursor`（JS `setTimeout` gate），然后 `start()` 立即播放；
    4) 更新指针：`scheduledCursor = max(scheduledCursor, currentTime) + buffer.duration`。
- 标签可视化：底部显示“正在按标签停顿 Ns（剩余 Ts）”，每 200ms 刷新，直到就位播放启动。
- 保留“数字令牌拦截”：过滤 `^\d+(\.\d+)?\s*(ms|s|秒)$` 的片段，不朗读。

3. UI 与开关
- 新增设置：
  - “显示停顿倒计时”开关（默认开启）。
  - “最大停顿上限（开发用）”默认关闭，严格遵循标签；仅用于临时验证。

## 验收用例
- `[pause:2s]`、`[pause:8s]`、`[pause:10s]`、`[pause:3秒]`、全角数字（如 `［pause：１０s］`）全部严格停对应秒数。
- 连续停顿 `2s + 8s + 4s` 累计停 14s 后继续播放；倒计时可见。
- 标签拆分到达时（SSE）仍能正确识别停顿；不会读出“3s/500ms/3秒”等数字令牌。
- 非停顿文本边到边解码并就位播放；无“读完第一句后卡很久”的误判（倒计时提示可见）。

## 实施步骤
1) 在解析层完善全角数字与括号闭合识别（保留残片，闭合后才产生命令）。
2) 在调度层实现“就位播放”与 JS gate：
   - 为每个音频片段记录 `targetStart = scheduledCursor`；
   - 解码完成时，如果 `currentTime < targetStart` → 使用 `start(targetStart)`；否则等待到 `targetStart` 再 `start()`。
3) 增加底部停顿倒计时显示（状态与剩余秒数）。
4) 保留数字令牌拦截与单位归一；新增设置开关。
5) 本地测试上述验收用例，确保时长精准。

---
确认后，我将按上述方案修改解析与调度，并添加倒计时提示，确保停顿时长与标签严格一致，同时保持流式体验。