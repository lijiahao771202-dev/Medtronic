## 问题分析
- 指令被朗读：流式分段在指令未完整到达（例如分拆的 "[pause:2" + "s]"）时，可能把前半段作为普通文本发送到 TTS，导致指令残片被朗读。
- 重复声音：语音通话页 `VoiceCall.jsx` 的短语排程未使用播放会话令牌，快速重试或并发流可能导致旧会话缓冲仍被调度。
- 不显示对话文本：当前通话界面只做语音，没有显示用户/智能体的文字记录。

## 修复方案
1) 指令防朗读
- 在短语派发到 TTS 前进行二次清洗：`stripInlineDirectives(phrase)` 移除任何 `[pause:...]`、`[rate:...]` 指令残片（包含不完整指令），确保文本永不包含指令被朗读。
- 在增量分段器中维护“指令态”状态机：当检测到 `[` 后进入指令模式，直到匹配到 `]` 才输出对应停顿/速率；指令模式中的字符不进入普通文本缓冲。

2) 防重复声音
- 在 `guidedTTS` 暴露 `beginPlaybackSession()` 返回 `playToken`，并在 `VoiceCall.jsx` 流式开始前调用它；短语排程前校验 `isActiveToken(playToken)`，若令牌不一致则丢弃缓冲。
- 在每次用户触发新的生成前调用 `stopSpeaking()` 并开启新会话令牌；页面卸载也清理。

3) 文字记录
- 在 `VoiceCall.jsx` 增加简洁的文字记录区（可折叠）：
  - 用户：显示语音识别到的最终文本（final transcript）
  - 智能体：实时累计 LLM 流式 token（合并为段落），与已播放短语保持一致。
- 默认收起，仅“显示文字”按钮可展开；保持电话 UI 简洁。

## 修改点
- 新增 `src/utils/stripDirectives.js`：提供 `stripInlineDirectives(text)`（不完整指令也能剔除）。
- 扩展 `src/utils/streamSegmentation.js`：加入指令态状态机；保证 push/flush 都不把指令内容进入普通文本。
- 扩展 `src/utils/guidedTTS.js`：
  - `beginPlaybackSession()`、`isActiveToken(token)`；为 `fetchAudioBuffer()` 和排程添加令牌校验钩子。
- 更新 `src/pages/VoiceCall.jsx`：
  - 在流式生成开始时开启新会话令牌；短语排程前做令牌校验与 `stripInlineDirectives`；
  - 增加文字记录区与折叠按钮；
  - 在每次重试/重新连接时调用 `stopSpeaking()` 并重置令牌与时间线。

## 验收标准
- 含有 `[pause]`、`[rate]` 的任何形式（完整/不完整）都不会被朗读为文本。
- 快速多次生成或重新连接时不出现多重声音；旧音频被丢弃。
- “显示文字”展开后能看到用户最终识别文本与智能体流式累积文本。

## 风险与兼容
- 浏览器语音识别不可用时，提供按住说话按钮降级：松开后批量发送文本，仍能分段与播放。
- 若需要更稳健的 STT/LLM 流式，可后续接入云端服务；本次先保证前端逻辑正确与 UI体验稳定。