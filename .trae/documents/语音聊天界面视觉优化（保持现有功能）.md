## 设计目标
- 不改动现有语音识别、生成与播放逻辑，仅优化 UI 结构与视觉。
- 加入“液态玻璃”背板，符合动态折射/弹性/色散三特性。
- 中心加入“随频率跳动的球”，与当前 `AnalyserNode` 同步。
- 底部仅保留两个按钮：左侧“按住说话”（长按触发）、右侧“挂断”。移除“显示文字”和“测试声音”。
- 将“提示词”按钮移动到玻璃面板右上角（弹层仍保留、默认隐藏）。

## 布局与组件
- GlassPanel（背板容器）：
  - 使用 `liquid-glass-react` 提供的 LiquidGlass 组件，作为半透明卡片背板。
  - 响应式宽度（移动优先），内边距与圆角，严格 CSS Modules 隔离。
- FrequencyOrb（中心球）：
  - 一个圆形元素，利用 `AnalyserNode` 的频谱数据计算能量，用 `transform: scale` 与轻微位移表现弹性。
  - 保留蓝色主题，叠加轻微 RGB 边缘色散（多层阴影/滤镜）。
- TopRightActions（右上角）：
  - 将“提示词”按钮放置在 GlassPanel 右上角，点击仍打开现有弹层。
- BottomBar（底部控制）：
  - 左：按住说话（长按开始、松开发送/停止）。
  - 右：挂断（停止播放与返回）。
  - 不再显示“显示文字”和“测试声音”按钮；不改动底层逻辑。

## 动效与实现要点
- 液态玻璃：
  - LiquidGlass（Displacement）叠加 `feTurbulence + feDisplacementMap` 或库内置效果。
  - 弹性：Hover/Press 使用 `transition: cubic-bezier` 或 `framer-motion`（已有依赖）实现轻微弹簧感。
  - 色散：伪元素多层 `drop-shadow` 或 `mix-blend-mode` 实现低强度 RGB 边缘分离。
- 频率球：
  - 从 `analyserRef` 读取 `getByteFrequencyData`，计算能量 E（中频段加权均值），以 `scale(1 + k*E)`+ 微位移驱动。
  - 在现有绘制循环中同步更新（不修改音频逻辑）。

## 交互（不改功能，仅改变触发方式）
- 长按说话：
  - `onPointerDown` 调用现有开始识别（仅当未识别时执行），`onPointerUp/Leave/Cancel` 调用停止识别。
  - 移动端使用 `touchstart/touchend` 兼容；不改识别与麦克风内部实现。
- 挂断：沿用当前停止播放与返回行为。
- 提示词：保持弹层编辑功能与持久化，改为 GlassPanel 右上角入口；默认不显示内容。

## 样式与响应式
- 新增/重构 `VoiceCall.module.css`：
  - `.glassPanel`（背板卡片）、`.orb`（频率球）、`.topRight`（提示词按钮）、`.bottomBar`（左右按钮），全部使用 `%/rem/vw` 并移动优先。
  - 保证色彩与现有主题一致，蓝色为主；背板透明度与 `backdrop-filter` 控制层次。

## 交付与验证
- 更新 `VoiceCall.jsx` 的结构（仅 UI 元素与事件绑定），保持现有 STT/TTS/代理逻辑不变。
- 验证：
  - 频率球随播放与语音输入跳动；
  - 长按说话工作正常（按下开始、松开停止）；
  - 挂断正常；
  - 提示词按钮在右上角可编辑；
  - 响应式在手机/桌面都正常显示；
  - 移除“显示文字”和“测试声音”。

---
确认后，我将按上述方案改造 `VoiceCall.jsx/VoiceCall.module.css`，复用现有 `analyserRef` 与事件函数，不触及任何生成或播放逻辑，仅做界面与交互方式优化。